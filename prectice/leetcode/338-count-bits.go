package main

import "fmt"

/*
题目：
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]


解题：
奇数: 都是前一个数+1，所以"1"的个数，也是前一项个数和再+1，这个+1，就是奇数的最末一位。(二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。)
0 == 0
1 == 1

2 == 10
3 == 11

偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
2 == 10
4 == 100
8 == 1000

3 == 11
6 == 110
12 == 1100

扩展：
计算其二进制数中的 0 的数目, 参见 countBitsZero 函数。

应用场景：
1. 计算二进制中的 1 or 0 个数，(还可以求和)
2. 实现 10 进制转换成 2 进制数的列表
 */
var num = 5

func main() {
	r := []int{0}
	for i := 1; i <= num; i++ {
		if i % 2 == 1 {
			r = append(r, r[i-1]+1)
		} else {
			r = append(r, r[i/2])
		}
	}

	fmt.Println(r)

	countBitsZero(10)
	DecimalToBinaryList(10)
}

/*
0 == 0
1 == 1
2 == 10
3 == 11
4 == 100
5 == 101
6 == 110
7 == 111
8 == 1000
9 == 1001
10 == 1010

分析：
奇数：二进制表示中，奇数一定比前面那个偶数少一个 0，因为最低位是 1。

偶数：二进制表示中，偶数中 0 的个数一定比除以 2 之后的那个数多一个。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 0 的个数要 +1 。
 */
func countBitsZero(n int) {
	r := []int{1}
	for i := 1; i <= n; i++ {
		if i % 2 == 1 {
			r = append(r, r[i-1]-1)
		} else {
			r = append(r, r[i/2]+1)
		}
	}
	fmt.Println(r)
}

func DecimalToBinaryList(n int) {
	r := []int{0}
	for i := 1; i <= n; i++ {
		if i % 2 == 1 {
			r = append(r, r[i-1] + 1)
		} else {
			r = append(r, r[i/2] * 10)
		}
	}
	fmt.Println(r)
}
